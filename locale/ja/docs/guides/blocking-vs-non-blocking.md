---
title: ブロッキングとノンブロッキングの概要
layout: docs.hbs
---


# ブロッキングとノンブロッキングの概要

この概要では、Node.js における**ブロッキング**と**ノンブロッキング**呼び出しの違いについて説明します。
この概要ではイベントループと libuv について説明しますが、
これらのトピックに関する事前知識は必要ありません。
読者は JavaScript 言語と Node.js コールバックパターンの基本的な知識を持っていることを前提としています。

> "I/O" とは、主に [libuv](https://libuv.org/) がサポートしている
> システムのディスクやネットワークとのやり取りを指します。


## ブロッキング

**ブロッキング**は、Node.js プロセス内の追加の JavaScript の実行が、
JavaScript 以外の操作が完了するまで待たなければならない場合です。
これは、**ブロッキング**操作が行われている間は
イベントループが JavaScript の実行を継続できないために起こります。

Node.js では、
I/O などの JavaScript 以外の操作を待機するのではなく、CPU に負荷がかかるためパフォーマンスが低下する JavaScript は通常、
**ブロッキング**としては呼び出されません。
Node.js 標準ライブラリの libuv を使用する同期メソッドは、最も一般的に使用されている**ブロッキング**操作です。
ネイティブモジュールには**ブロッキング**メソッドもあります。

Node.js 標準ライブラリのすべての I/O メソッドは非同期バージョンを提供します。
これらは**ノンブロッキング**で、コールバック関数を受け入れます。
一部のメソッドには**ブロッキング**に対応したものもあり、
その名前は `Sync` で終わります。


## コードを比較する

**ブロッキング**メソッドは同期的に実行され、
**ノンブロッキング**メソッドは非同期的に実行されます。

例としてファイルシステムモジュールを使用する場合、これは**同期的な**ファイルの読み取りです:

```js
const fs = require('fs');
const data = fs.readFileSync('/file.md'); // ファイルが読み込まれるまでここでブロック
```

そして、これは同等の**非同期的な**コードの例です:

```js
const fs = require('fs');
fs.readFile('/file.md', (err, data) => {
  if (err) throw err;
});
```

最初の例は2番目の例よりも単純に見えますが、
2行目がファイル全体が読み取られるまで追加の JavaScript の実行を**ブロックする**という欠点があります。
同期バージョンでは、エラーがスローされた場合はそれをキャッチする必要があるか、
プロセスがクラッシュします。
非同期バージョンでは、
示されているようにエラーをスローするかどうかを決めるのは開発者次第です。

例を少しだけ拡張しましょう:

```js
const fs = require('fs');
const data = fs.readFileSync('/file.md'); // ファイルが読み込まれるまでここでブロック
console.log(data);
moreWork(); // console.log の後に実行されます
```

そして、これは似ていますが、同等ではない非同期の例です。

```js
const fs = require('fs');
fs.readFile('/file.md', (err, data) => {
  if (err) throw err;
  console.log(data);
});
moreWork(); // console.log の前に実行されます
```

上記の最初の例では、`console.log` が `moreWork()` の前に呼び出されます。
2番目の例では、`fs.readFile()` は**ノンブロッキング**であるため、JavaScript の実行は続行でき、
`moreWork()` が最初に呼び出されます。
ファイルの読み込みが完了するのを待たずに `moreWork()` を実行する機能は、
より高いスループットを可能にする重要な設計上の選択です。


## 並行性とスループット

Node.js での JavaScript の実行はシングルスレッドであるため、
同時実行性とは、他の作業が完了した後に JavaScript コールバック関数を実行するイベントループの能力のことです。
同時に実行されることが予想されるコードでは、
I/O などの JavaScript 以外の操作が発生しても、
イベントループの実行を継続できる必要があります。

例として、Web サーバへの各リクエストが完了するのに 50 ミリ秒かかり、
その 50 ミリ秒のうち 45 ミリ秒が非同期に実行できるデータベース入出力である場合を考えてみましょう。
**ノンブロッキング**の非同期操作を選択すると、
他のリクエストを処理するために 1 リクエストあたり 45 ミリ秒が解放されます。
これは、**ブロッキング**メソッドの代わりに**ノンブロッキング**メソッドを使用することを選択しただけで、
キャパシティが大きく異なることを意味します。

イベントループは、
並行作業を処理するために追加のスレッドが作成される可能性がある他の多くの言語のモデルとは異なります。


## ブロッキングコードとノンブロッキングコードが混在する危険性

I/O を扱うときに避けるべきいくつかのパターンがあります。
例を見てみましょう。

```js
const fs = require('fs');
fs.readFile('/file.md', (err, data) => {
  if (err) throw err;
  console.log(data);
});
fs.unlinkSync('/file.md');
```

上記の例では、`fs.unlinkSync()` は
`fs.readFile()` の前に実行される可能性が高いため、
`file.md` は実際に読み取られる前に削除されます。
これを書くためのより良い方法は、
完全に**ノンブロッキング**で正しい順序で実行されることが保証されていることです。

```js
const fs = require('fs');
fs.readFile('/file.md', (readFileErr, data) => {
  if (readFileErr) throw readFileErr;
  console.log(data);
  fs.unlink('/file.md', (unlinkErr) => {
    if (unlinkErr) throw unlinkErr;
  });
});
```

上記は、`fs.readFile()`のコールバック内で `fs.unlink()` への**ノンブロッキング**呼び出しを行います。
これにより、正しい操作順序が保証されます。


## 追加のリソース

- [libuv](https://libuv.org/)
- [About Node.js](/ja/about/)
